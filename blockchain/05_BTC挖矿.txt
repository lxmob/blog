比特币是基于交易的分类账(transaction-based ledger)
这种交易模式隐私保护性好，需要在交易过程中说明币的来源
它没有账户的概念，没有数据结构去记录你有几个比特币
当A用户发生一笔交易时，只能通过A币的输入来源进行推算，有多少输出指向A的账户地址


UTXO集合是什么？
比特币系统中全节点要在内存中维护一个UTXO的数据结构(unspent transaction output)
是指所有没有被花掉的输出所组成的集合就是UTXO，在UTXO的集合中检查当前输出是否存在
当发生一笔交易时，这样做是为了能够让全节点快速的检测double spending
每笔交易可能会有多个输入和多个输出
所有输入的金额要等于输出的金额(total inputs = total outputs)
也有情况是(total inputs > total outputs)多出的部分会作为矿工的出块手续费


比特币区块交易信息
https://explorer.btc.com/zh-CN/btc/blocks


挖矿的过程是什么？
挖矿(mining)就是在查找一个随机数(nonce)，属于区块头中的一个阈值
这个nonce会和区块头里的其它信息合在一起作为输入取哈希值
计算出哈希值要小于或等于某个指定的目标阈值(临界值)
H(nonce+block header) <= target
挖矿的过程就是在不停的试各种随机数，使得整个区块头取哈希值后落在指定的范围内
这个计算过程是没有捷径的，只能一个个的去计算nonce，才能找到符合要求的解
这个计算过程被称为工作量证明(proof of work)


挖矿很难验证很容易(difficult to solve, but easy to verify)
一旦有人找到这个nonce然后通过广播发布出去，其他人要验证这个nonce是否符合要求是很容易的
nonce作为区块头的一部分，只要算一次哈希值是否小于等于这个目标阈值就可以了


区块头中nonce阈值，它的类型是32位无符号整数
nonce的输出空间最多只有2^32个可能的取值，按照目前的挖矿难度就算是把2^32个可能的取值
都遍历一遍很可能仍然是找不到符合难度要求的target，比特币的热度导致挖矿难度的增加
单纯靠调整区块头中的这个nonce是大概率找不到target，搜索空间不够大


如何增大搜索空间呢？
每个发布的区块里都有一笔特殊的铸币交易，这笔交易是没有输入只有输出的
它有一个coinbase域可以在这里面写入信息，这个域中是没有其他人会去检查你写入了什么
当更改了铸币交易中coinbase域的信息，这个交易的哈希值就会产生变化
通过默克尔树向上传递，最后导致区块头中的merkle root hash发生变化
所以可以把它当作额外的随机数空间(extra-nonce)
例如把coinbase中前8byte作为extra-nonce来使用，这样搜索空间就增大到2^96(1byte=8bit)
所以真正挖矿的时候是有两层循环的，外层循环去调整extra-nonce的难度，内层循环去寻找符合的目标阈


伯努利试验(bernoulli trial)
这种实验只有两种结果的可能性，例如掷硬币，正面朝上的概率是p，反面朝上的概率就是1-p
通过大量的试验就会形成伯努利过程(bernoulli process)
这个过程是属于无记忆性(memoryless)
在大量的实验中前面的结果对后面的结果是没有影响的，概率是一致的


对于挖矿来说每次尝试的nonce成功可能性很小，那么就需要尝试大量的nonce
尝试的过程属于progress free，不会因为你之前尝试了多次而增大下一次出现的概率
如果有一个puzzle不满足progress free那么就会导致某个节点过去做的工作量越多
下次出现成功的概率就越大，这样就不满足随机性了，会有不成比例的优势


挖矿过程是一个概率问题，假设有90%的算力掌握在诚实节点的手里
并不能保证记账权就一定落在诚实的节点手中
每一个矿工，能够挖到下一个区块的时间取决于矿工的算力占据系统算力的百分比
例如你的算力占据系统的1%那么系统中每产生100个区块中就有一个区块是你挖出来的


什么是矿池？
单个矿工的收入是不稳定，所以就产生了矿池，矿池是由多个矿机来驱动一个全节点
矿主将哈希值计算交给矿工处理，矿工计算好哈希值后提交给矿主


收益该如何分配呢？
矿主将目标数降低难度然后分配给矿工
矿工接收到后开始计算这个share，只要矿工挖到了这个share把它提交给矿主
矿主会记录矿工提交了多少次这个share，将来等到某个矿工真的挖到了合法的区块之后
按照每个矿工提交的share数目进行分配收益，作为矿工工作量证明的一个衡量标准
