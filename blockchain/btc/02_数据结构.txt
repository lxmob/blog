比特币中的两种数据结构

哈希指针(hash pointers)
普通的指针存储的是某个结构体在内存中的地址
哈希指针除了要存储这个地址以外还要保存这个结构体的哈希值
这样做的好处就是为了防止数据篡改

区块链(block chain)
一个个区块组成的链表，哈希指针代替了普通指针
区块链与普通的链表有什么区别呢？

区块链中第一个区块又被称为创世纪块(genesis block)
区块链中最新一个区块(most recent block)，将hash pointers保存在系统中
每一个区块都包含指向前一个区块的hash pointers
当前区块哈希值是由前面区块头内容包括它的hash pointers合在一起取哈希值

通过这样的数据结构可以实现防篡改(temper-evident log)
如果中间有一个区块内容被篡改，那么后面区块的hash pointers就会对不上
最终导致系统中保存最后一个区块的hash pointers也对不上
这种数据结构的好处就是只需要保存最后一个区块的哈希指针就可以检测出对链上所有区块的更改
通过这种性质比特币中有些节点就可以只保存最近几千个区块，以前的就可以不用存了
如果用到以前的区块，可以向其他节点去要这个区块，有些节点可能是恶意的
我们可以通过hash pointers性质，去计算要过来区块的哈希指针是否被篡改过

默克尔树(merkle tree)
https://en.wikipedia.org/wiki/Merkle_tree
默克尔树与二叉树(binary tree)的区别是什么呢？
哈希指针代替了普通指针
这种数据结构的好处，只需要保存根节点哈希值(root hash)就可以检测树中所有节点的修改

比特币中每一个区块内所包含的交易都是组织成merkle tree的形式
merkle tree底部的数据块都是一条交易transaction(tx)
block header内保存merkle tree的根哈希值，block body内保存交易信息列表

默克尔树的作用就是提供merkle proof
比特币中的节点分为两类
1.全节点(full node)保存block内所有的信息
2.轻节点(light node)只保存block header信息例如比特币钱包应用

如何向一个轻节点去证明某一条交易是写入区块链中呢？
这里就要用到merkle proof，找到这笔交易所在的位置
然后从这条交易节点一直向上找到根节点，而这条查找的路径就是merkle proof
轻节点可以通过计算当前交易记录的哈希值与向全节点请求来的哈希值做合并
计算出上一个父节点的哈希值，最终计算出根节点的哈希值，时间复杂度属于O(logn)
轻节点将计算出的哈希值与block header保存的哈希值做对比，就可以证明这条交易是否存在于区块中
包含证明(proof of membership / proof of inclusion)
http://zhenxiao.com/blockchain/03-BTC.pdf

如何向一个轻节点去证明一条交易不在当前区块链中呢？
proof of non-membership
时间复杂度属于O(logn)代价是需要排个序(sorted merkle tree)
首先对交易内容取一次哈希值，然后将merkle tree叶子节点进行哈希值从小到大排序
假设当前这条交易在某两个交易节点中间，向轻节点提供的这两条proof合并后与根节点哈希值对比
如果没有被改变过说明这两个节点在merkle tree中确实是两个相邻的节点，要找的那条交易是插在这两个节点中间的
但是它并没有出现，那么就证明了当前这条交易不存在区块中，比特币中没有使用这种硬性需求去证明这条交易不存在区块中

全节点
1.一直在线
2.在本地硬盘上维护完整的区块链信息
3.在内存里维护utxo集合，以便快速检验交易的合法性
4.监听比特币网络上的交易信息，验证每个交易的合法性
5.决定哪些交易会被打包到区块内
6.监听别的矿工挖出来的区块，验证其合法性
  验证区块内交易的合法性，铸币交易是否被篡改，发布的区块是否符合难度要求
  每两周按照比特币协议规定调整挖矿难度，验证区块是否在最长合法链上
7.挖矿
  决定沿着哪个链挖下去，默认情况下按照最长合法链挖下去
  当出现等长分叉的时候，选择哪一条分叉，默认是按照最先监听到的区块

轻节点(spv client)
1.不是一直在线
2.不用保存整个区块链，只要保存每个区块的块头
3.不用保存全部交易，只保存与自己相关的交易
4.无法检验大多数交易的合法性，只能检验与自己相关的那些交易的合法性
5.无法检测网上发布区块的准确性
6.可以验证挖矿的难度
7.只能检测到哪条是最长链，不知道哪条是最长合法链
