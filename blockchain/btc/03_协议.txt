数字货币发行
纸质货币是由国家批量印钞统一发行，每一张纸质货币都具备防伪标志
数字货币也可以由国家发行属于中心化管理，国家央行通过私钥对数字货币进行签名
这样大家就可以通过央行公钥验证手中数字货币的真伪
假设现在发生一笔交易，由我向你转入一个数字货币
你可以通过这笔交易验证数字货币的真伪，验证后确实是由央行所发行的，交易完成
这里面数字货币并没有用到区块链技术，而是用到了密码学中的非对称加密算法

双花攻击(double spending attack)
数字货币就是一块数据文件是由央行发行的，文件的内容是不可以伪造的，但是可以复制
当发生交易时向商家购买100元的商品，将100元数字货币交付给商家
然后将100元数字货币复制多份，对复制后的100元数字货币进行多处支付
这就是与纸质货币的区别，纸质货币交易出去就没有了，这个就是双花攻击、双重支付

数字货币面临的主要挑战就是怎么防范双花攻击
具体解决方案，让央行在数据库中维护一张表，来记录发行数字货币的编号
通过这个编号在表中维护当前编号的数字货币在谁手中，每当发生交易时不仅要验证该币的真伪
还要向央行验证这个币是否在对方手中，如果确实存在那么交易通过
然后央行再把这个币的编号记录指向下一个人，这样就能够防止双花攻击，这种方式属于中心化的方案

如何使用去中心化的方式来构建一套数字货币方案呢？
比特币就是为了解决这个问题而诞生的，去中心化的方式要解决数字货币的两个问题
1.数字货币由谁发行、发行的时间、发行的数量？
2.如何验证交易的有效性、怎么防止双花攻击？

比如说有一个用户A他获得了发行货币的权力铸币权(create coin)
假设A发行了10个比特币，A将10个比特币交易给B和C，每个人给5个比特币
这笔交易需要A的签名(signed by A)证明是A同意的
同时这笔交易还要说明交易10个比特币的来源(来源指向铸币交易)

比特币系统中每笔交易都包含了输入和输出两个部分
输入要说明币的来源，输出部分要给出收款人的公钥哈希
交易区块中除了哈希指针还有另外一种指针指向前面某个交易的，是为了说明币的来源
为什么要说明币的来源？
保证了该币的来源不是凭空捏造出来的，同时防范了双花攻击

用户A要给B转账首先需要知道B的公钥地址，还要知道A币的来源是否满足这次交易
同时B要知道A的公钥地址说明这笔交易是由A转账过来的，而且所有节点都需要知道A的公钥
为了验证区块交易内中A的签名，来说明这笔交易是否是合法的

怎么才能知道A的公钥？
输入不仅要包含A币的来源还要包含A的公钥，A的公钥是在交易中自己给出来的
但是A的公钥又不能让A去说明，这样会产生安全漏洞，假设B'去伪造A的交易说自己公钥是A的
然后用自己的私钥签名，在其它节点收到交易后用假的公钥去验证签名确实是对的，就会以为这笔交易是合法的
那么B'相当于把A账上的钱偷走了

怎么防范这个问题呢？
在A产生铸币交易(coinbase tx)时它的输出里面就有A的公钥哈希
转账交易中说明的A的公钥要与A币来源里面的公钥哈希对的上才行

比特中验证交易的过程是通过执行脚本实现的
每个交易的输入作为一段脚本程序、输出作为一段脚本程序(bitcoin script)
将当前交易块的输入脚本与上一个区块中提供币来源的输出脚本合并一起运行如果没有任何错误就是验证通过

每个交易区块都中包含区块头和区块体
block body中保存交易信息生成的merkle tree
block header中包含了以下信息
1.version(比特币版本协议)
2.hash of previous block header(指向前一个区块指针)
3.merkle root hash(默克尔树根节点)
4.target(挖矿难度目标阈值)
5.nonce(随机数)

哈希指针指向的是block header，取哈希的时候是将block header内容全部取哈希值
所以区块链串联起来的只是block header，但是block header中又保存了merkle root hash
串联的区块中所有的block body就可以看成transaction list

上面讨论的在系统中所有节点都需要验证交易
系统中大多数节点都属于轻节点，全节点的数目不多
轻节点是没有参与区块链的构造和维护，它只是利用区块链的信息做一些查询之类的事务

区块链账本的内容需要达到分布式的共识(distributed consensus)
即我本地维护的账本要和你本地维护的账本达成一致，才能叫做去中心化账本
如果每个人的维护的账本都不一样就缺乏了一致性，这样就没有任何意义

比特币共识(consensus in bitcoin)
比特币中共识要解决的一个问题是有些节点可能是恶意的，假设系统中有大多数节点是好的
有恶意的节点只是占用一小部分，在这样的情况下如何设计一个共识协议呢？
可以通过投票的方式让参与交易的节点都进行投票少数服从多数来达成共识，决定是否将这个区块写入到账本中
谁都可以投票，那就会产生问题

女巫攻击(Sybil Attack)
攻击者通过创建多个账号节点来达成对系统的控制
https://en.wikipedia.org/wiki/Sybil_attack

比特币中采用的也是投票方式，但不是按照账户数目投票，而是通过计算力投票
每个节点都可以在本地将合法的交易组装成区块然后开始不断的尝试nonce值(4byte)
如果有一个找到符合的nonce那么它就获得了记账权，将区块写入区块链中然后进行广播
其它节点收到消息后要验证一下区块的合法性，首先检查block header中目标阈值是否符合
然后检查block body里面的交易列表，验证一下每个交易是否都是合法的，是否有签名、是否被双花
如果有一项不符合要求那么这个区块是不能被节点接受的

假设当前区块被节点验证过了是合法的那么其它节点就应该接受它吗？
该问题描述的是当前区块不是最新的区块，是插在中间的一个位置，出现算力不对等的情况
遵循最长合法链原则(longest valid chain)，比特币系统中被接受的区块应该是在最长合法链上的

分叉攻击(forking attack)
通过向区块链中间插入一个区块，来回滚某个已经发生的交易

区块链在正常情况下也可能发生分叉，有两个节点同时获得记账权
这种等长的临时性分叉会维持一段时间，直到有一个分叉是胜出的，遵循最长合法链原则
那如果短链中发生的铸币交易，在后续的记账中是不会被大多数诚实节点所接受的

大家争抢记账权是为了得到出块奖励(block reward)
这也是比特币系统在设计时候最巧妙的一种方式，通过出块奖励激励矿工来将交易打包成区块
比特币协议中规定获得记账权的那个节点，在发布的区块里可以有一个特殊交易
就是前面说的铸币交易(coinbase transaction)，在这个交易中可以发行一定数量的比特币
比特币协议规定在最开始记账时每一个区块奖励是50BTC，在21万个区块后这个奖励要减半也就是12.5BTC
当一个节点获得的哈希率(hash rate)越高那么这个节点得到记账权的权重就会越高，出块奖励概率也越大
