以太坊应该设计怎样的数据结构来实现账户与账户状态的映射呢？


方案一(hash table)
通过key-value pair来映射数据，如果不考虑哈希碰撞的话是可以使用的
但是如何向轻节点提供merkle proof呢？
假设你要证明账户余额，将哈希表中元素组织成merkle tree算一下根哈希值
保存在block header里，如果产生新的交易区块就必然会导致哈希表内容发生变化
然后发布下一个区块时再将哈希表中元素组织成merkle tree吗？
实际上新发布区块中所包含的交易与之关联的账户才会发生变化，大多数账户的状态是不变的
所以每次都生成merkle tree，所付出的代价是很大的

比特币中每新发布一个区块不也要组成merkle tree的吗？
比特币中是将每一个区块内的交易都组成一个merkle tree
下一个区块中所包含新的交易又是独立的merkle tre，而且区块内交易条数是4000条
发布之后的区块merkle tree是固定不变的，以太坊中是要将所有的账户构建merkle tree
两者对比数据不是一个数量级的

提供merkle proof还有另外一个用处保证所有全节点的一致性
哈希表本身的效率是很好的无论是插入还是查询都是常数级别的
但是每次新发布区块，构建merkle tree的代价是很大的


方案二(merkle tree)
通过merkle tree来保存账户状态，每个区块发布只更新一小部分账户
所以只改树中一小部分，缺点是merkle tree没有提供一个高效的更新和查找的方法

如果使用merkle tree那么需要排序吗？

如果不排序呢？
如果不排序的话，不规定叶子节点出现的顺序那么构建出来的merkle tree不是唯一的

比特币中不也是不排序的吗，为什么不存在这样的问题？
比特币中全节点收到merkle tree的顺序也是不一致的
比特币中记账权是只能由一个全节点发布，其他全节点按照新发布的区块来达成共识
而以太坊中想要实现这种方式是要将交易发布到区块内，而不是发布账户状态

如果排序呢？
每次有新账户加入时，所插入的地方，后面账户所组成的merkle tree都需要发生变化


以太坊采用的数据结构是压缩前缀树(MPT merkle patricia tree)
http://zhenxiao.com/blockchain/16-ETH.pdf


前缀树(trie)
又称为字典树，查询时间复杂度是O(L)，L是字符串的长度

字典树的三个基本性质
1.根节点不包含字符，除根节点外每一个节点都只包含一个字符
2.从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串
3.每个节点的所有子节点包含的字符都不相同

trie数据结构的优点？
1.如果按照账户地址(0-f 16进制)存储，一个节点最多分叉17次
2.查找效率取决于key的长度，键值越长查找的内存次数就越多
3.不会产生哈希碰撞，只要是地址不一样映射的就是两个位置的输出
4.不同顺序的地址排列，在trie中展现的形式还是一样的
5.局部更新友好，不需要遍历整颗树

trie数据结构的缺点？
每个节点只保存一个字符，会产生大量的内存浪费，空间换时间
如果能够将这些节点合并，就不会产生内存浪费，并且查询时间也会更快


压缩字典树(patricia tree)
对于这种数据结构，如果要新增账户，原来压缩的节点可能需要扩展开
键值分布比较稀疏的时候，采取路径压缩方式比较好，恰好以太坊账户就是这样
以太坊账户地址是2^160，地址足够长足够稀疏才不会发生哈希碰撞

MPT与patricia tree有什么区别？
merkle patricia tree也是通过哈希指针连接，最终保存根哈希值

这个根哈希值在以太坊中有什么作用？
1.证明每个账户的状态是没有篡改过的
2.证明每个账户中的余额是多少
3.证明某个账户是不存在的

怎么证明？
该账户所在的分支整个向上路径作为merkle proof发给轻节点
轻节点就可以验证一下账户里有多少钱


以太坊中采用的还不是原生的merkle patricia tree
而是对merkle patricia tree做了一些修改(modified MPT)
每当发布新区块时，有一些账户状态会发生变化，这些变化不是在树中原节点上改变
而是新建一些分支，原来的状态是会保留下来的

以太坊中的数据结构是由大的MPT包含很多小的MPT，每一个合约账户的存储都是一个小的MPT
所以系统中全节点需要维护的不是一颗MPT，而是每次出现一个区块都要新建一个MPT
只不过这些状态树中大部分节点是共享的，只有少数发生变化的节点需要新建分支


为什么要保留历史状态？
如果发生分叉攻击，我们需要把当前状态回滚(roll back)到区块中发生交易的前一个状态
如果要支持回滚必须要保留历史状态，因为以太坊中是智能合约，智能合约代码是自动执行
没有办法推算出前一个状态是什么


以太坊中存储key-value pair
是将状态(value)通过RLP(recursive length prefix)序列化形式存储
RLP是一种极简主义，它只支持一种类型字节组成的数组支持嵌套(nested array of bytes)
