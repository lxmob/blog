比特币中的两种数据结构

hash pointers
普通的指针存储的是某个结构体在内存中的地址
哈希指针除了要存储这个地址还要保存这个结构体的哈希值，这样做的好处防止数据篡改

基本结构block chain
一个个区块组成的链表，区块链与普通的链表有什么区别呢？
哈希指针代替了普通指针

区块链中第一个区块又被称为创世纪块genesis block
区块链最后一个区块是最新产生的most recent block，同时将最后一个区块的hash pointers保存在系统中
每一个区块都包含指向前一个区块的hash pointers
当前区块哈希值是由前面区块内容包括它的hash pointers合在一起取哈希值

通过这样的数据结构可以实现temper-evident log
如果中间有一个区块内容被篡改，那么后面区块的hash pointers就会对不上
最终导致系统中保存最后一个区块的hash pointers也对不上
这种数据结构的好处就是只需要保存最后一个区块的哈希指针就可以检测出对链上所有区块的更改
通过这种性质比特币中有些节点就可以只保存最近几千个区块，以前的就可以不用存了
如果用到以前的区块，可以向其他节点去要这个区块，有些节点可能是恶意的
我们可以通过hash pointers性质，去计算要过来区块的哈希指针是否被篡改过

默克尔树merkle tree
https://en.wikipedia.org/wiki/Merkle_tree
默克尔树与二叉树(binary tree)的区别是什么呢？
哈希指针代替了普通指针
这种数据结构的好处，只需要保存root hash就可以检测树中所有节点的修改

比特币中每一个区块内所包含的交易都是组织成merkle tree的形式
每一颗merkle tree最底部的区块都是一条交易transaction(tx)
每一个区块中都包含block header和block body
区块头内保存merkle tree的根哈希值，区块体内保存交易信息列表
https://www.woshipm.com/blockchain/1022259.html

默克尔树的作用就是提供merkle proof，比特币中的节点分为两类
1.全节点(full node)保存block内所有的信息
2.轻节点(light node)例如比特币钱包应用只保存block header

proof of membership / proof of inclusion
证明的时间和空间复杂度属于O(logn)
如何向一个轻节点去证明某一条交易是写入区块链中呢？
这里就要用到merkle proof，找到这笔交易所在的位置
然后从这条交易节点一直向上找到根节点，而这条查找的路径就是merkle proof
轻节点可以通过计算当前交易记录的哈希值与向全节点请求来的哈希值做合并
然后计算出上一个父节点的哈希值，这个过程类似于递归合并最终计算出根节点的哈希值
轻节点将计算出的哈希值与block header保存的哈希值做对比，就可以证明这条交易是否存在于区块中
http://zhenxiao.com/blockchain/03-BTC.pdf

proof of non-membership
证明的时间和空间复杂度属于O(logn)代价是需要排个序sorted merkle tree
如何向一个轻节点去证明一条交易不在当前区块链中呢？
首先对交易内容取一次哈希值，然后将merkle tree叶子节点进行哈希值从小到大排序
假设当前这条交易在某两个交易节点中间，向轻节点提供的这两条proof合并后与根节点哈希值也是没有被改变过的
说明这两个节点在merkle tree中确实是两个相邻的节点，要找的那条交易是插在这两个节点中间的
但是它并没有出现，那么就证明了当前这条交易不存在区块中，比特币中没有使用这种硬性需求去证明这条交易不存在区块中
