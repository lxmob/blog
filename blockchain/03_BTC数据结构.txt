什么是哈希指针？
普通的指针存储的是某个结构体在内存中的地址
哈希指针除了要存储这个地址以外还要保存这个结构体的哈希值
这样做的好处就是为了防止数据篡改


区块链是什么？
区块链是一项技术，是将每一个区块通过链表连接起来，一个不可篡改的分布式数据库账本
而比特币区块链中的区块是由block header与block body组成
每一个区块体中都包含了这个区块内的所有交易，区块头中包含各种阈值


区块链中第一个区块又被称为创世纪块(genesis block)
每一个区块都包含指向前一个区块的哈希指针(hash pointers)
最新的区块哈希值是由前面区块头内容包括它的哈希指针合在一起取哈希值
通过这样的数据结构可以实现防篡改(temper-evident log)
如果中间有一个区块内容被篡改，那么后面区块的哈希指针都会发生改变
这种数据结构的好处是只需要保存最后一个区块的哈希指针就可以检测出对链上所有区块的更改


默克尔树(merkle tree)
又称为哈希树，默克尔树中每个叶子节点都作为数据标签
除了叶子节点的其它节点内容是由叶子节点取哈希值后得到的
只需要保存根节点哈希值(merkle root hash)就可以检测树中所有节点的修改
用来防止数据被恶意篡改，默克尔树与二叉树的区别使用哈希指针代替了普通指针


比特币中每一个区块内所包含的交易组织成默克尔树的形式
每一个区块内都是一颗独立的树，树中每一个叶子节点数据块都是一条交易(tx/transaction)
区块头内保存默克尔树的根哈希值，区块体内保存交易信息列表


默克尔树的作用就是用来提供哈希值证明(merkle proof)
首先介绍一下比特币中的节点，主要分为两类
全节点(full node)保存区块内所有的信息
轻节点(light node)只保存区块头信息，例如比特币钱包应用


什么是哈希值证明？
哈希值证明是由发生交易的叶子节点，一直向上查找根节点的路径就是merkle proof
查找的过程，首先轻节点会向全节点发送查找请求，请求的是树中路径另一半的哈希值
然后由当前交易的哈希值与请求到的哈希值，递归合并计算出根节点的哈希值
这里的查询过程时间复杂度属于O(logn)级别
轻节点可以将计算出的根哈希值与保存在区块头中的根哈希值做对比
就可以确定这条交易是否存在于区块中(proof of membership)


不懂的话可以参考肖臻教授的pdf一步步理解
http://zhenxiao.com/blockchain/03-BTC.pdf


不包含证明(proof of non-membership)
向一个轻节点去证明某条交易不在当前区块链中
对默克尔树中叶子节点进行排序(sorted merkle tree)
首先对交易内容取一次哈希值，然后将默克尔树叶子节点进行哈希值从小到大排序
假设当前这条交易在某两个交易节点中间，向轻节点提供的这两条merkle proof
如果没有被改变过说明这两个节点在默克尔树中确实是两个相邻的节点
要找的那条交易是插入在这两个节点中间的，但是它并没有出现
那么就证明了当前这条交易不存在区块中
比特币中没有使用这种硬性需求去证明这条交易不存在区块中
