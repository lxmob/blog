/* 
  作用域
  当函数被定义时，生成的一个 JS 内部的隐式属性 [[scopes]] 也是函数作用域链的存储容器

  作用域链是栈结构，存储的是函数执行期上下文 AO 与全局执行期上下文 GO
  函数执行完毕后 AO 是要销毁的，每当函数执行时 AO 都会重新创建，遵循即时性原则

  作用域链就是将 AO 与 GO 执行期上下文形成链式排列起来，查找变量参数的一种规则
*/


/* 
  形成过程
  1. 当一个函数被定义时，生成一个 JS 内部的隐式属性 [[scopes]] 用来存储作用域链的容器
  2. 作用域链中（栈结构）的第一项值指向的是 GO 全局执行期上下文
    （根据函数被定义时所处的环境如果是内部函数则第一项是外部函数的AO）
  3. 当函数被调用时，在函数执行前（预编译阶段）作用域链顶端是自身的 AO 函数执行期上下文
    （这点也解释了为什么在函数外部无法访问函数内部的变量，因为作用域链里根本就没有对应的 AO 执行环境）
  4. 将自身 AO 压入栈后，第二项是全局的 GO，查找变量的规则从顶端依次向下查找
  5. 在函数执行完毕后，对应函数的 AO 将会被销毁
*/

function a(){
  function b(){
    function c(){}
    c();
    console.dir(c);
  }
  b();
  console.dir(b);
}
a();
console.dir(a);

// a被定义时： a.[[scopes]] -> 0 : GO
// a预编译时： a.[[scopes]] -> 0 : a -> AO
//                           1 : GO
// b被定义时： b.[[scopes]] -> 0 : a -> AO
//                           1 : GO
// b预编译时： b.[[scopes]] -> 0 : b -> AO
//                           1 : a -> AO
//                           2 : GO
// c被定义时： c.[[scopes]] -> 0 : b -> AO
//                           1 : a -> AO
//                           2 : GO
// c预编译时： c.[[scopes]] -> 0 : c -> AO
//                           1 : b -> AO
//                           2 : a -> AO
//                           3 : GO
// c执行结束： c.[[scopes]] -> 0 : b -> AO
//                           1 : a -> AO
//                           2 : GO
// b执行结束： b.[[scopes]] -> 0 : a -> AO
//                           1 : GO
//           c.[[scopes]] X
// a执行结束： a.[[scopes]] -> 0 : GO
//           b.[[scopes]] X
