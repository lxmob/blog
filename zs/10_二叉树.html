<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>二叉树</title>
  </head>
  <body>
    <!--  
      二叉树由头部父节点分叉左右子节点，子节点再依次进行分叉，连续的结构
      同时各个子节点之间相互不串联，这就是二叉树

          1
        2   3
      4  5 6 7
      先序：头左右，输出 = 1,2,4,5,3,6,7
      中序：左头右，输出 = 4,2,5,1,6,3,7
      后序：左右头，输出 = 4,5,2,6,7,3,1

          1
        2   3
      递归序：输出 = 1,2,2,2,1,3,3,3,1
    -->
  </body>

  <script>
    // 二叉树节点结构
    class TreeNode {
      left = null;
      right = null;
      constructor(val) {
        this.val = val;
      }
    }

    // 先序
    function preQueue(head) {
      if (head == null) {
        return null;
      }
      console.log(head.val);
      pre(head.left);
      pre(head.right);
    }

    // 中序
    function inQueue(head) {
      if (head == null) {
        return null;
      }
      inQueue(head.left);
      console.log(head.val);
      inQueue(head.right);
    }

    // 后序
    function posQueue(head) {
      if (head == null) {
        return null;
      }
      posQueue(head.left);
      posQueue(head.right);
      console.log(head.val);
    }

    // 递归序
    function f(head) {
      if (head == null) {
        return null;
      }
      // 1
      f(head.left);
      // 2
      f(head.right);
      // 3
    }

    // 对比两颗树节点是否相同
    // https://leetcode.cn/problems/same-tree/description/
    function isSameTree(p, q) {
      // 左树与右树只要有一个节点与另一颗树的节点没有对上那么结构就不同返回 false
      if ((p == null) ^ (q == null)) {
        return false;
      }
      // 两颗树头节点都为空
      if (p == null && q == null) {
        return true;
      }
      // 都不为空
      return (
        p.val == q.val &&
        isSameTree(p.left, q.left) &&
        isSameTree(p.right, q.right)
      );
    }

    // 判断一颗树是否是镜面树
    // https://leetcode.cn/problems/symmetric-tree/description/
    function isSymmetric(root) {
      function isMirror(h1, h2) {
        if ((h1 == null) ^ (h2 == null)) {
          return false;
        }
        if (h1 == null && h2 == null) {
          return true;
        }
        return (
          h1.val == h2.val &&
          isMirror(h1.left, h2.right) &&
          isMirror(h1.right, h2.left)
        );
      }
      return isMirror(root, root);
    }

    // 返回一颗树的最大深度
    // https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/
    function maxDepth(root) {
      if (root == null) {
        return 0;
      }
      // 取左树与右树的最大值最后再 + root
      return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }

    // 从先序数组和中序数组构建一颗树
    // https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/
    function buildTree(pre, inn) {
      if (pre == null || inn == null || pre.length != inn.length) {
        return null;
      }
      function f(pre, L1, R1, inn, L2, R2) {
        // 越界情况
        // 先序 [1,2,3] 中序 [2,3,1]
        if (L1 > R1) {
          return null;
        }
        var head = new TreeNode(pre[L1]);
        if (L1 == R1) {
          return head;
        }
        // 先序：L1(头) - R1
        // 中序：L2 - find - R2
        // 中序左树 = L2 - find-1，中序右树 = find+1 - R2
        // 先序左树 = L1+1 - (find-L2)，先序右树 = (find-L2+1) - R1
        var find = L2;
        for (; inn[find] != pre[L1]; find++);
        head.left = f(pre, L1 + 1, L1 + find - L2, inn, L2, find - 1);
        head.right = f(pre, L1 + find - L2 + 1, R1, inn, find + 1, R2);
        return head;
      }
      return f(pre, 0, pre.length - 1, inn, 0, inn.length - 1);
    }

    // 优化版
    function buildTree2(pre, inn) {
      var pLen = pre.length,
        iLen = inn.length;
      if (pre == null || inn == null || pLen != iLen) {
        return null;
      }
      // 空间换时间
      var hashMap = new Map();
      for (var i = 0; i < iLen; i++) hashMap.set(inn[i], i);
      // 时间复杂度 O(n) 有n个子节点 f 函数就被调用n次
      function f(pre, L1, R1, inn, L2, R2, hashMap) {
        if (L1 > R1) {
          return null;
        }
        var head = new TreeNode(pre[L1]);
        if (L1 == R1) {
          return head;
        }
        var find = hashMap.get(pre[L1]);
        head.left = f(pre, L1 + 1, L1 + find - L2, inn, L2, find - 1, hashMap);
        head.right = f(pre, L1 + find - L2 + 1, R1, inn, find + 1, R2, hashMap);
        return head;
      }
      return f(pre, 0, pre.length - 1, inn, 0, inn.length - 1, hashMap);
    }

    // 二叉树层序遍历并收集节点
    // https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/
    function levelOrderBottom(root) {
      var nList = [],
        queue = [root];
      // 正序的实现，开启一个队列
      // 1. 拿出此时队列中的 size，size有多少第二步就执行多少次
      // 2. 弹出节点，然后收集节点先左后右加入队列
      while (queue.length != 0 && root != null) {
        var size = queue.length,
          curLevel = [];
        for (var i = 0; i < size; i++) {
          var { val, left, right } = queue.shift();
          curLevel.push(val);
          if (left != null) queue.push(left);
          if (right != null) queue.push(right);
        }
        nList.unshift(curLevel);
      }
      return nList;
    }

    // 判断是否是平衡二叉树
    // 平衡树：每一颗子树左树高度与右树高度差 <= 1
    // https://leetcode.cn/problems/balanced-binary-tree/description/
    function isBalanced(root) {
      // 以某个节点头的时候返回两个信息
      // 1.整颗树是否是平的
      // 2.整颗树的高度是什么
      function info(isBld, h) {
        return { isBalanced: isBld, height: h };
      }
      function process(head) {
        if (head == null) {
          return info(true, 0);
        }
        var { isBalanced: lIsBld, height: lH } = process(head.left),
          { isBalanced: rIsBld, height: rH } = process(head.right),
          height = Math.max(lH, rH) + 1,
          isBalanced = lIsBld && rIsBld && Math.abs(lH - rH) < 2;
        return info(isBalanced, height);
      }
      return process(root).isBalanced;
    }

    // 搜索树：每一颗子树左树的值都比头小右树的值都比头大
    // 左树搜索树最大 max < x，右树搜索树最小 > x
    // https://leetcode.cn/problems/validate-binary-search-tree/description/
    function isValidBST(root) {
      if (root == null) {
        return true;
      }
      // 以某个节点头的时候返回三个信息
      // 1.整颗树是否是搜索树
      // 2.整颗树的最大值 max
      // 3.整颗树的最小值 min
      function info(isBST, max, min) {
        return { isBST, max, min };
      }
      function process(head) {
        // 如果当前树是空就返回空
        if (head == null) {
          return null;
        }
        var leftInfo = process(head.left),
          rightInfo = process(head.right),
          max = head.val, // 保存当前树的最大值和最小值
          min = head.val;
        // 搜索左树和右树的信息
        if (leftInfo != null) {
          max = Math.max(leftInfo.max, max);
          min = Math.min(leftInfo.min, min);
        }
        if (rightInfo != null) {
          max = Math.max(rightInfo.max, max);
          min = Math.min(rightInfo.min, min);
        }
        var isBST = true;
        // 如果左树和右树不为空且不是搜索树
        if (leftInfo != null && !leftInfo.isBST) {
          isBST = false;
        }
        if (rightInfo != null && !rightInfo.isBST) {
          isBST = false;
        }
        // left max < head  right min > head
        // 1.如果左树或右树是空那么它就是搜索树没有节点可搜索
        // 2.如果左树最大值 < 当前头的值且右树最小值 > 当前头的值那么它就是搜索树
        var leftMaxLessNum = leftInfo == null ? true : leftInfo.max < head.val,
          rightMinMoreNum = rightInfo == null ? true : rightInfo.min > head.val;
        if (!leftMaxLessNum || !rightMinMoreNum) {
          isBST = false;
        }
        return info(isBST, max, min);
      }
      return process(root).isBST;
    }

    // 路径总和
    // 从头到叶子节点的路径值总和等于目标数
    // https://leetcode.cn/problems/path-sum/description/
    function hasPathSum(root, tSum) {
      if (root == null) {
        return false;
      }
      var isSum = false;
      process(root, 0, tSum);
      function process(head, preSum, tSum) {
        // 当前是叶子节点
        if (head.left == null && head.right == null) {
          if (head.val + preSum == tSum) {
            isSum = true;
          }
          return;
        }
        // 非叶子节点
        preSum += head.val;
        if (head.left != null) {
          process(head.left, preSum, tSum);
        }
        if (head.right != null) {
          process(head.right, preSum, tSum);
        }
      }
      return isSum;
    }

    // 路径总和同时记录达成总和的路径
    // https://leetcode.cn/problems/path-sum-ii/description/
    function pathSum(root, tSum) {
      var ans = [],
        path = [];
      if (root == null) {
        return ans;
      }
      function process(head, preSum, tSum) {
        // base case 叶子节点
        if (head.left == null && head.right == null) {
          if (preSum + head.val == tSum) {
            path.push(head.val);
            ans.push(path.slice());
            path.pop();
          }
          return;
        }
        // 非叶子节点
        path.push(head.val);
        preSum += head.val;
        if (head.left != null) {
          process(head.left, preSum, tSum);
        }
        if (head.right != null) {
          process(head.right, preSum, tSum);
        }
        path.pop();
      }
      process(root, 0, tSum);
      return ans;
    }
  </script>
</html>
