/* 
  位运算
  任何一个数在计算机底层都是以 32 位信息组成的
  按照二进制表示以一个 int 1 => [00000000000000000000000000000001]

  java中32位信息中可以表示的数字范围 (-2的31次方) - (2的31次方 -1)

  java中 int 最大数为21e+在32位信息中表示的是 
  => [01111111111111111111111111111111]
  => 可以表示最大 int 数就是 (2的31次方 -1)

  为什么要保留最高位数呢
  => 因为 int 即可以表示正数也可以表示负数，属于有符号 int 数，但是有符号数比没有无符号数大（少一位）
  => 如果符号位（最高位）是 0 就表示一定是非负数

  负数表示
  => [11111111111111111111111111111111]
  => 符号位一定是 1 除了符号位要知道是负几就要看后面的数
  => 不看符号位后面的数就等于 (~取反 + 1)
  => 0 是被算到非负领域中的所以在非负数中最大数是 (2的31次方 -1)
  => 在 java 中 int 最大数绝对值要比最小数绝对值少 1

  负数为什么要(~取反 + 1)呢
  => 在32位信息中加减乘除取余 并不是按照十进制进行运算的而是翻译成二进制位运算进行计算
  => 计算机在底层计算时按照位运算，如果 a+b 中 a 是正数 b 也是正数那么大家按照正数位运算计算
      但是如果 a+b 中 a 是正数 b 是负数难道还需要再走一套正负的逻辑进行位运算吗
  => 底层不想这么干，所以设计的位运算中只走一套逻辑就想在实际执行的时候快一点
  => 例如 n 数负数就等于 = -n = (~n + 1)

  如果是最小负数取相反数是什么
  => -2147483648 = 2147483648 还是它本身
  => 最小数取反 10000000000000000000000000000000 = (01111111111111111111111111111111 + 1)

  如果是0取反是什么
  => 0 二进制表示 = 00000000000000000000000000000000
  => 取反表示 = (11111111111111111111111111111111 + 1) = 100000000000000000000000000000000
  => 33位溢出了省略 = 00000000000000000000000000000000


  JS位运算符
  << 左移操作符 => 将第一个操作位数向左移动指定的位数，拿 0 补位
  >> 右移操作符 => 将第一个操作位数向右移动指定的位数，拿符号位补位
  >>> 无符号右移操作符 => 将第一个操作位数向右移动指定的位数，拿 0 补位
  & 按位与运算 => 只有当两个数对应的二进制位都为 1 时该位的结果才为 1，否则为 0
  ~ 按位非运算 => 将操作数的位反转
  | 按位或运算 => 在其中一个或两个操作数对应的二进制位为 1 时，该结果值为 1
  ^ 按位异或运算 => 在两个操作数中仅有一个对应的二进制位为 1 时，该结果为 1
*/

// 输出一个数的 32 位信息
function print32(num){
  var n = '';
  for(var i = 31; i >= 0; i--){
    n += (num & (1 << i)) === 0 ? 0 : 1;
  }
  return n;
}

// 每左移一位操作数平方 +1
// 1 => 0...01
// 2 => 0...10 => 2的1次方
// 3 => 0...11
// 4 => 0...100 => 左移动一位 => 2的2次方
// 一个数左移的结果就等于这个数乘以2的结果
// num << 1 => num*2

console.log(1 << 2); // 2的2次方 => 4
console.log(1 << 3); // 2的3次方 => 8

console.log(1 & 2); // 0 => 00000000000000000000000000000001 & 00000000000000000000000000000010
console.log(1 & 3); // 1 => 00000000000000000000000000000001 & 00000000000000000000000000000011
console.log(1 & 5); // 1 => 00000000000000000000000000000001 & 00000000000000000000000000000101

console.log(~1); // -2 => 00000000000000000000000000000001 => 11111111111111111111111111111110
console.log(~3); // -4 => 00000000000000000000000000000011 => 11111111111111111111111111111100

console.log(print32(1)); // 00000000000000000000000000000001
console.log(print32(4)); // 00000000000000000000000000000100
console.log(print32(8)); // 00000000000000000000000000001000

var a = 1,
    b = -1,
    c = ~a + 1;
console.log(a, b, c); // 1 -1 -1

// 5 = 00000000000000000000000000000101
// => 1符号位不看，剩余数取反+1
// => 11111111111111111111111111111010 + 1
// -5 = 11111111111111111111111111111011
// 走一套逻辑将 -5 转 5
// => 00000000000000000000000000000100 + 1
// 5 = 00000000000000000000000000000101
console.log(print32(5));
console.log(print32(-5));

console.log(print32(-2147483648)); // 10000000000000000000000000000000
console.log(print32(2147483648)); // 10000000000000000000000000000000