<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>归并排序和快速排序</title>
  </head>
  <body></body>

  <script>
    // 归并排序
    // D&C分治法将已有序的子序合并得到完全有序的序列
    // 子序如何做到有序
    // 取两个子序指针移动对比大小拷贝值到新数组中当有一个子序指针越界即合并另一个子序中剩余项
    // 时间复杂度 O(n) * O(logN)
    // 自上而下的递归版本
    function mergeSort(arr) {
      if (arr == null || arr.length < 2) {
        return;
      }
      process(arr, 0, arr.length - 1);
      function process(arr, L, R) {
        // base case 边界相等
        if (L == R) {
          return;
        }
        var mid = L + ((R - L) >> 1);
        // D&C
        process(arr, L, mid);
        process(arr, mid + 1, R);
        merge(arr, L, mid, R);
      }
    }
    function merge(arr, L, M, R) {
      var nArr = [],
        i = 0,
        p1 = L, // 左子序指针
        p2 = M + 1; // 右子序指针
      // 未越界情况
      while (p1 <= M && p2 <= R) {
        nArr[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
      }
      // p1或者p2越界，不可能同时越界
      while (p1 <= M) {
        nArr[i++] = arr[p1++];
      }
      while (p2 <= R) {
        nArr[i++] = arr[p2++];
      }
      // 覆盖原数组
      for (var j = 0; j < nArr.length; j++) {
        arr[L + j] = nArr[j];
      }
    }

    var arr = [2, 4, 2, 9, 8, 7, 2, 1, 4, 3, 6, 5, 4];
    // console.log(arr);
    // mergeSort(arr);
    // console.log(arr);

    // 归并排序自下而上迭代版本
    function mergeSort2(arr) {
      if (arr == null || arr.length < 2) {
        return;
      }
      var N = arr.length,
        mergeSize = 1; // 步长
      while (mergeSize < N) {
        var L = 0;
        while (L < N) {
          // 在没有右组的情况左组边界溢出凑不够步长的数
          if (mergeSize >= N - L) {
            break;
          }
          var M = L + mergeSize - 1,
            R = M + Math.min(mergeSize, N - M - 1);
          merge(arr, L, M, R);
          L = R + 1;
        }
        if (mergeSize > Math.floor(N / 2)) {
          break;
        }
        mergeSize <<= 1;
      }
    }

    // console.log(arr);
    // mergeSort2(arr);
    // console.log(arr);

    // 快速排序
    // 相当于在冒泡排序的基础上采用D&C分治法
    function swap(arr, i, j) {
      var temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
    }

    // 第一版分层：选择序列中最后p数实现将<=p放左边>p的放右边
    // 0.分区<=区
    // 1.当前数<=p，当前数和<=区的下一个数做交换，<=区右扩，跳下一个
    // 2.当前数>p，直接跳到下一个
    function partition1(arr) {
      var lessEqualR = -1,
        index = 0,
        mostR = arr.length - 1;
      while (index <= mostR) {
        if (arr[index] <= arr[mostR]) {
          swap(arr, index++, ++lessEqualR);
        } else {
          index++;
        }
      }
    }

    // 第二版分层：选择序列中最后p数实现将<p放左边>p放右边=p放中间
    // 0.分区<区 >区
    // 1.当前数<p，当前数和<区下一个数做交换，<区右扩，跳下一个
    // 2.当前数>p，当前数和>区上一个数做交换，>区左扩，当前数不动
    // 3.当前数=p，直接跳下一个
    // 4.当前数与>区边界撞上了停止迭代
    // 5.最后一个数与>区第一个数做交换结束
    function partition2(arr) {
      var N = arr.length,
        lessR = -1,
        moreL = N - 1,
        index = 0;
      while (index < moreL) {
        if (arr[index] < arr[N - 1]) {
          swap(arr, index++, ++lessR);
        } else if (arr[index] > arr[N - 1]) {
          swap(arr, index, --moreL);
        } else {
          index++;
        }
      }
      swap(arr, N - 1, moreL);
    }

    // 递归实现数据量大时js容易造成函数调用栈溢出
    // ps:9100条数据就调用栈溢出了哈哈
    function quickSort(arr) {
      if (arr == null || arr.length < 2) {
        return;
      }
      process(arr, 0, arr.length - 1);
      function swap(arr, i, j) {
        var temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
      // 第三版分层：arr[L...R]范围上，拿arr[R]做划分值
      // 返回=区的左右边界
      function partition(arr, L, R) {
        var lessR = L - 1,
          moreL = R,
          index = L;
        while (index < moreL) {
          if (arr[index] < arr[R]) {
            swap(arr, index++, ++lessR);
          } else if (arr[index] > arr[R]) {
            swap(arr, index, --moreL);
          } else {
            index++;
          }
        }
        swap(arr, R, moreL);
        return { equalL: lessR + 1, equalR: moreL };
      }
      function process(arr, L, R) {
        if (L >= R) {
          return;
        }
        // L < R
        var equalInfo = partition(arr, L, R);
        process(arr, L, equalInfo.equalL - 1);
        process(arr, equalInfo.equalR + 1, R);
      }
    }
  </script>
</html>
