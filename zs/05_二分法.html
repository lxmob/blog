<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>二分法</title>
  </head>
  <body></body>

  <script>
    // 有序数组中找到 num
    // [1, 2, 2, 4, 6, 7, 9, 10]
    // 在一个有序的列表中每次都进行折半查找，折半就有上终点和下终点，4或者6统一按照上终点作为结束
    // 如果我们的目标数是 9
    // 第一次查找上终点是 4, 4 之前的数是有序的全部小于 9, ok全都不看
    // [6, 7, 9, 10]
    // 第二次查找上终点是 7, 7 之前的数是有序的全部小于 9, ok全都不看
    // [9, 10]
    // 第三次查找上终点是 9, 9 目标数完成
    // 如果目标数是 5 最终查找都没找出则返回 false
    function find(arr, num) {
      if (arr == null || arr.length == 0) {
        return false;
      }
      var L = 0,
        R = arr.length - 1;
      // arr[L...R]  num  arr[0...N-1]
      while (L <= R) {
        var mid = Math.floor((L + R) / 2);
        if (arr[mid] == num) {
          return true;
        } else if (arr[mid] < num) {
          L = mid + 1;
        } else {
          R = mid - 1;
        }
      }
      return false;
    }

    var arr = [1, 2, 2, 4, 6, 7, 9, 10];
    console.log(find(arr, 1));
    console.log(find(arr, 9));
    console.log(find(arr, 11));

    // 有序数组中找到 >= num 最左的位置
    // [1, 2, 2, 4, 4, 4, 6, 7, 9, 10]
    // 查找的目标数是 4 最左的位置
    // 第一次查找上终点是 4，ok找到拿变量 ans 保存位置 ans = 4
    // 接下来要看左侧位置还有没有 >= 4 的数，继续二分
    // [1, 2, 2, 4, 4]
    // 第二次查找上终点 2, ok小于 4 全部都不看
    // [4, 4]
    // 第三次查找上终点 4, ok找到拿变量 ans 保存位置 ans = 3
    // 二分结束最晚抓到位置的 ans 返回
    function mostLeftNoLessNumIndex(arr, num) {
      if (arr == null || arr.length == 0) {
        return -1;
      }
      var L = 0,
        R = arr.length - 1,
        ans = -1;
      while (L <= R) {
        var mid = Math.floor((L + R) / 2);
        if (arr[mid] >= num) {
          ans = mid;
          R = mid - 1;
        } else {
          L = mid + 1;
        }
      }
      return ans;
    }

    var arr1 = [1, 2, 2, 4, 4, 4, 6, 7, 9, 10];
    console.log(mostLeftNoLessNumIndex(arr1, 4));
    console.log(mostLeftNoLessNumIndex(arr1, 9));
    console.log(mostLeftNoLessNumIndex(arr1, 2));

    // 有序数组中找到 <= num 最右的位置
    function mostRightNoLargerNumIndex(arr, num) {
      if (arr == null || arr.length == 0) {
        return -1;
      }
      var L = 0,
        R = arr.length - 1,
        ans = -1;
      while (L <= R) {
        var mid = Math.floor((L + R) / 2);
        if (arr[mid] <= num) {
          ans = mid;
          L = mid + 1;
        } else {
          R = mid - 1;
        }
      }
      return ans;
    }

    var arr1 = [1, 2, 2, 4, 4, 4, 6, 7, 9, 10];
    console.log(mostRightNoLargerNumIndex(arr1, 4));
    console.log(mostRightNoLargerNumIndex(arr1, 9));
    console.log(mostRightNoLargerNumIndex(arr1, 2));

    // 在无序的数组中相邻的数不等
    // 局部最小值问题
    // 1. [0] < [1] 0位置数最小
    // 2. [n-2] > [n-1] n-1位置数最小
    // 3. 左 > [i] < 右 i位置数最小
    // 找到无序数组中其中一个局部最小即可
    // 如果 [0] < [1] 上的数直接返回 [0] 的数，假设 [0] > [1] 上的数走势则是下降趋势
    // 如果 [n-2] > [n-1] 上的数直接返回 [n-1] 的数，假设 [n-2] < [n-1] 上的数走势则是上扬趋势
    // 那么 [0...n-1] 范围中必有局部最小的数
    // 二分取 mid 数，如果 [mid] 的数即比左边小也比右边小直接返回 [mid]
    // 假设 [mid-1] > [mid] 上的数则断言 [mid-1...mid] 的数是局部上扬走势
    // 那么 [0...mid] 范围中必有局部最小的数
    function oneMinIndex(arr) {
      if (arr == null || arr.length == 0) {
        return -1;
      }
      var N = arr.length;
      if (N == 1) {
        return 0;
      }
      if (arr[0] < arr[1]) {
        return 0;
      }
      if (arr[N - 1] < arr[N - 2]) {
        return N - 1;
      }
      var L = 0,
        R = N - 1;
      // L m R => L m R-1 R 防止指针越界
      while (L < R - 1) {
        var mid = Math.floor((L + R) / 2);
        if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid + 1]) {
          return mid;
        } else {
          // 1 左 > mid mid > 右
          // 2 左 < mid mid < 右
          // 3 左 < mid mid > 右
          if (arr[mid] > arr[mid - 1]) {
            R = mid - 1;
          } else {
            L = mid + 1;
          }
        }
      }
      return arr[L] < arr[R] ? L : R;
    }

    // 随机生成数组，相邻且不相等
    function randomArray(maxLen, maxValue) {
      var len = parseInt(Math.random() * maxLen),
        arr = Array(len);
      if (len > 0) {
        arr[0] = parseInt(Math.random() * maxValue);
        for (var i = 1; i < len; i++) {
          do {
            arr[i] = parseInt(Math.random() * maxValue);
          } while (arr[i] == arr[i - 1]);
        }
      }
      return arr;
    }

    function check(arr, minIndex) {
      if (arr.length == 0) {
        return minIndex == -1;
      }
      var left = minIndex - 1,
        right = minIndex + 1,
        leftBigger = left >= 0 ? arr[left] > arr[minIndex] : true,
        rightBigger = right < arr.length ? arr[right] > arr[minIndex] : true;
      return leftBigger && rightBigger;
    }

    function printArray(arr) {
      for (var i = 0; i < arr.length; i++) {
        console.log(arr[i]);
      }
    }

    function testOneMinIndex() {
      var maxLen = 10,
        maxValue = 200,
        testTime = 100000;
      console.log('测试开始');
      for (var i = 0; i < testTime; i++) {
        var arr = randomArray(maxLen, maxValue),
          ans = oneMinIndex(arr);
        if (!check(arr, ans)) {
          printArray(arr);
          console.log('ans: ', ans);
          break;
        }
      }
      console.log('测试结束');
    }

    testOneMinIndex();
  </script>
</html>
