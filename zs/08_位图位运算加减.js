/* 
  位图
  在 java 中使用 hashset 集合来存储 32 个数 int 类型每个数占用 4 字节相当于 32 * 4
  可以通过 32 位二进制信息来表示 32 位数那么就相当于我一个 int 类型的数就表示了 32 个数(0-31)
  java 中有 long 类型来表示 64位存储信息占用 8 字节

  private long[] bits;

  public BitMap(int max){ 
    // 申请一个max长度的数组
    // (max + 64) >> 6 => (max + 64) / 64
    // 如果想表示 0~0 范围的数 long 类型至少准备一个数只不过只占 1 个位置的数
    // 0~63 范围的数 = int (63 + 64) / 64 = 1 还是一个数
    bits = new long[(max + 64) >> 6]
  }

  public void add(int num){
    // num >> 6 => num / 64 
    // 定位到哪一个整数例如 bits[2] = 0-63,64-127,128-191
    // num % 64 => num & 63
    // 170 % 64 = 42 => 010101010 & 000111111 = 000101010 = 42
    // 1L = 1long类型的64位信息 = 1
    // 1L << 42 = 左移位数就表示 42 这个数
    // 然后将这个数在第几位整数按位或进去
    bits[num >> 6] |= (1L << (num & 63))
  }

  public void delete(int num){
    // 按位与按位取反的数就等于把这个数在这个位置上删除
    bits[num >> 6] &= ~(1L << (num & 63))
  }
*/


/* 
  位运算实现 +
  46 + 20
  a' = 0101110 ^ 0010100 = 0111010 = 58
  b' = (0101110 & 0010100) << 1 = 0001000 = 8
  a'' = 0111010 ^ 0001000 = 0110010 = 50
  b'' = (0111010 & 0001000) << 1 = 0010000 = 16
  a''' = 0110010 ^ 0010000 = 0100010 = 34
  b''' = (0110010 & 0010000) << 1 = 0100000 = 32
  a'''' = 0100010 ^ 0100000 = 0000010 = 2
  b'''' = (0100010 & 0100000) << 1 = 1000000 = 64
  a''''' = 0000010 ^ 1000000 = 1000010 = 66
  b''''' = (0000010 & 1000000) << 1 = 0
*/
function add(a, b){
  var sum = a;
  while(b != 0){
    sum = a ^ b; // 无进位相加信息 = sum
    b = (a & b) << 1; // 进位信息 = b'
    a = sum; // a' 无进位相加的信息
  }
  return sum;
}
console.log(add(46, 20));


/*  
  位运算实现 -
  a - b = a + b的相反数 = a + (~b + 1)
  不能出现 + 号 = add(a, add(~b, 1))
*/
function negNum(n){
  return add(~n, 1);
}
function minus(a, b){
  return add(a, negNum(b));
}
console.log(minus(46, 20));


/* 
  位运算实现 *
  a * b => 0110 * 1010 => 6 * 10
      0110
  *   1010
  --------
      0000 => 位数是0就全补0 => 看b数个位补数就在个位
     0110  => 位数是1就补a数 => 看b数十位补数就在十位
    0000   => 补0
   0110    => 补a数
  --------
   0111100 = 60
*/
function multi(a, b){
  var ans = 0;
  // b = 0 结束
  while(b != 0){
    // b => 1010 & 0001 = 0
    // b => 0101 & 0001 = 1
    // b => 0010 & 0001 = 0
    // b => 0001 & 0001 = 1
    if((b & 1) != 0){
      // 0 + 01100
      // 0 + 01100 + 0110000
      ans = add(ans, a);
    }
    // a => 01100
    // b => 0101
    // a => 011000
    // b => 0010
    // a => 0110000
    // b => 0001
    // a => 01100000
    // b => 0000
    a <<= 1;
    b >>>= 1;
  }
  // ans = 0 + 01100 + 0110000 = 0111100 = 60
  return ans;
}
console.log(multi(6, 10));


// 位运算实现除法
function isNeg(num){
  return num < 0;
}
function div(a, b){
  var x = isNeg(a) ? negNum(a) : a,
      y = isNeg(b) ? negNum(b) : b,
      ans = 0;
  // 除去符号位 i 从 30位开始
  for(var i = 30; i >= 0; i = minus(i, 1)){
    // x 向右移 i 位直到 >= y
    // 001100 / 000010 = 12 / 2 = 6
    // i = 2 => 000011 >= 000010
    // ans = 000100
    // x = 001100 - 001000 = 000100
    // i = 1 => 000010 >= 000010
    // ans = 000110
    // x = 000100 - 000100 = 0
    if(x >> i >= y){
      ans |= 1 << i;
      x = minus(x, y << i);
    }
  }
  // 如果 a 与 b 中有一个负数结果就是负数反之就是正数
  return isNeg(a) ^ isNeg(b) ? negNum(ans) : ans;
}