/*
  & 按位与运算
  二进制数对应位数都是 1 时结果为 1，反之为 0

  3 & 6
  00000011
  00000110
  ---------
  00000010 = 2

  -3 & 8
  10000011 = 负数参与运算先反码再转补码 = 11111000 = 11111101

  11111101
  00001000
  ---------
  00001000 = 8
*/
console.log('3 & 6 =', 3 & 6);
console.log('-3 & 8 =', -3 & 8);

/*
  | 按位或运算
  二进制数对应位数有一个或两个 1 时结果为 1

  3 | 6
  00000011
  00000110
  ---------
  00000111 = 7

  -3 | 8
  10000011 = 11111101

  11111101
  00001000
  ---------
  11111101 = 由于是负数补码跟负数原码是不一样的所以需要转反码再转原码 = 11111100 = 10000011 = -3
*/
console.log('3 | 6 =', 3 | 6);
console.log('3 | 6 =', -3 | 8);

/*
  ~ 按位非运算
  二进制数对应的每一位位数取反包括符号位

  ~9
  00001001
  11110110 = 负数补码转反码再转原码 = 11110101 = 10001010 = -10

  ~-6
  10000110 = 负数运算转反码再转补码 = 11111010
  = 补码再进行取反得到正数补码，正数补码与原码相同 = 00000101 = 5
*/
console.log('~9 =', ~9);
console.log('~6 =', ~-6);

/*
  ^ 按位异或运算
  二进制数对应位数仅有一位为 1 时结果为 1，否则为 0

  3 ^ 6
  00000011
  00000110
  ---------
  00000101 = 5

  7 ^ -2
  00000111
  10000010 = 负数运算先转反码再转补码运算 = 11111101 = 11111110

  00000111
  11111110
  ---------
  11111001 = 负数补码转负数原码 = 11111000 = 10000111 = -7
*/
console.log('3 ^ 6 =', 3 ^ 6);
console.log('7 ^ -2 =', 7 ^ -2);

/*
  >> 带符号右移运算
  正数与负数右移一位都是 / 2

  6 >> 1
  00000110 = 00000011 = 3

  -6 >> 1
  10000110 = 负数原码参与运算转反码后再转补码 = 11111001 = 11111010 = 11111010 >> 1 = 11111101

  11111101 = 结果得到的是负数补码需要转反码后再转原码 = 11111100 = 10000011 = -3
*/
console.log('6 >> 1 =', 6 >> 1);
console.log('-6 >> 1 =', -6 >> 1);

/*
  << 带符号左移运算
  左移直接拿 0 补位，正负数都是 * 2

  5 << 1
  00000101 = 00001010 = 10
*/
console.log('5 << 1 =', 5 << 1);

/*
  >>> 无符号右移运算
  忽略符号位，拿 0 补位
*/
