/*
  计算机在底层进行算术运算时只做加法
  在设计位运算时，想通过一套逻辑解决正数与负数的运算
  只走一套逻辑是为了在实际执行的时候更快一点

  二进制正负数
  二进制数的最高位代表正负数（也可以叫符号位）
  0 代表正数
  1 代表负数

  以 8 位二进制数来表示

  二进制数的原码
    5 = (0)0000101
   -5 = (1)0000101

  二进制数的反码
  正数的反码与原码相同，负数除去符号位，其它余数取反
    5 = (0)0000101
   -5 = (1)1111010

  二进制数的补码
  正数的补码与原码相同，负数反码 + 1
    5 = (0)0000101
   -5 = (1)1111011

  参与计算

  原码相加
    00000101
    00000101
  -----------
    10001010 = 2^1 + 2^3 = 2 + 8 = -10 结果是不对的

  反码相加
    00000101
    11111010
  -----------
    11111111 = 反码需要先把符号位外的数转为原码 = 10000000 = -0 值没有一对一原则
  
  补码相加
    00000101
    11111011
  -----------
   100000000 = 结果溢出保持 8 位去掉溢出位 = 00000000 = 0

  所以计算机在存储数据时都是以补码的形式进行存储

  在 32 位操作系统中的计算机对任意一个数都是以 32 位信息组成的
  具有符号位所以能表示的最大数的范围是 (-2^31) —— (2^31 - 1) = -2147483648 —— 2147483647
  最大的正数：0111 1111 1111 1111 1111 1111 1111 1111
  最大的负数：1000 0000 0000 0000 0000 0000 0000 0000
  负数比正数大 1 是因为在符号位 0 被算到非负领域中，所以在计算范围内最大正数比最大负数少 1

  原码来表示一个数的二进制形式
  反码来表示一个负数的二进制形式
  补码来表示计算机底层运算的逻辑
*/
function print32(num){
  var n = '';
  for(var i = 31; i >= 0; i--){
    n += (num & (1 << i)) === 0 ? 0 : 1;
  }
  return n;
}
