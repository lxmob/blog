<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>优先级队列</title>
  </head>
  <body></body>

  <script>
    // 小根堆 => 优先级队列
    class PriorityQueue {
      constructor(compare) {
        if (typeof compare !== 'function') {
          throw new Error('compare function required!');
        }
        this.data = [];
        this.compare = compare;
      }

      // 二分查找插入的位置 O(logn)
      search(num) {
        var L = 0,
          R = this.data.length;
        while (L < R) {
          var mid = L + ((R - L) >> 1);
          if (this.compare(this.data[mid], num) > 0) {
            R = mid;
          } else {
            L = mid + 1;
          }
        }
        return L;
      }

      offer(elem) {
        var idx = this.search(elem);
        this.data.splice(idx, 0, elem);
        return this.data.length;
      }

      poll() {
        return this.data.shift();
      }

      peek() {
        return this.data[0];
      }

      isEmpty() {
        return this.data.length == 0;
      }
    }

    var compare = function (a, b) {
      if (typeof a !== 'number' || typeof b !== 'number') {
        throw new Error('compare expect a number!');
      }
      // leetcode测试需要将这里改成 a.val - b.val
      return a - b;
    };

    var heap = new PriorityQueue(compare);
    heap.offer(1);
    heap.offer(10);
    heap.offer(8);
    heap.offer(6);
    heap.offer(3);
    heap.offer(5);
    console.log(heap.peek());
    console.log(heap.poll());
    console.log(heap);

    // 合并K个升序链表
    // https://leetcode.cn/problems/merge-k-sorted-lists/description/
    function mergeKLists(lists) {
      if (lists == null) {
        return null;
      }
      var heap = new PriorityQueue(compare);
      for (var i = 0; i < lists.length; i++) {
        if (lists[i] != null) {
          heap.offer(lists[i]);
        }
      }
      if (heap.isEmpty()) {
        return null;
      }
      var head = heap.poll(),
        pre = head;
      if (pre.next != null) {
        heap.offer(pre.next);
      }
      while (!heap.isEmpty()) {
        var cur = heap.poll();
        pre.next = cur;
        pre = cur;
        if (cur.next != null) {
          heap.offer(cur.next);
        }
      }
      return head;
    }
  </script>
</html>
