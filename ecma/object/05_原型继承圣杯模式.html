<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>继承圣杯模式</title>
  </head>
  <body></body>
  <!-- 
    通过实例化一个对象来继承构造函数的原型对象 prototype
    缺点：会导致 new 出来的实例共用一块原型对象内存，且没有办法向父类传递参数。
  -->
  <script>
    function Dog(name, age) {
      this.name = name;
      this.age = age;
      this.toys = ["线球", "磨牙棒"];
    }
    Husky.prototype = new Dog();
    function Husky() {}
    var husky1 = new Husky();
    var husky2 = new Husky();
    husky2.toys.push("肚兜");
    console.log(husky1, husky2); // 共用一块内存数据
  </script>

  <!-- 
    原型继承缓冲区（圣杯模式）
    产生的问题：在父类原型对象上赋值的属性，如果将子类的原型指向父类原型，子类更改原型对象上的属性，将会导致父类原型对象属性变更，引用的同一块地址。
    解决方案：创建一个缓冲区，通过一个纯净的对象来作为中间件存储属性，并将中间件的原型对象指向父类原型。
  -->
  <script>
    Person.prototype.phone = "iphone12";
    function Person() {}
    function Student() {}
    function inherit(Target, Origin) {
      function Buffer() {}
      Buffer.prototype = Origin.prototype;
      Target.prototype = new Buffer();
      Target.prototype.constructor = Target;
      Target.prototype.super_class = Origin;
    }
    inherit(Student, Person);
    var s = new Student();
    // 完美解决在子类原型对象上更改属性且不影响父类原型问题，同时还能够操作父类属性和方法。
    Student.prototype.phone = "iphone6";
    var p = new Person();
    console.log(s, p);
  </script>

  <!-- 
    插件改造 ES5 模块化开发
  -->
  <script>
    var inheritPlugin = (function () {
      var Buffer = function () {};
      return function (Target, Origin) {
        Buffer.prototype = Origin.prototype;
        Target.prototype = new Buffer();
        Target.prototype.constructor = Target;
        Target.prototype.super_class = Origin;
      };
    })();
    Person.prototype.phone = "iphone12";
    function Person() {}
    function Student() {}
    inheritPlugin(Student, Person);
    var s = new Student();
    Student.prototype.phone = "iphone6";
    var p = new Person();
    console.log(s, p);
  </script>

  <!-- 
    根据业务按需求再封装
  -->
  <script>
    var InitAllPerson = (function () {
      function Person() {}
      Person.prototype = {
        eat: function () {
          console.log("我喜欢吃:", this.food);
        },
        run: function () {
          console.log("我喜欢运动:", this.sport);
        },
      };
      function Student() {}
      function Teacher() {}
      Student.prototype = { food: "水果", sport: "游泳" };
      Teacher.prototype = { food: "豆汁", sport: "跑步" };
      inheritPlugin(Student, Person);
      inheritPlugin(Teacher, Person);
      return { Student, Teacher };
    })();
    var s = new InitAllPerson.Student();
    InitAllPerson.Student.prototype.phone = "iphone6";
    var t = new InitAllPerson.Teacher();
    console.log(s, t);
  </script>
</html>
