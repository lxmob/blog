<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>对象的浅拷贝与深拷贝</title>
  </head>
  <body></body>
  <!-- 
    浅拷贝只拷贝对象的第一层属性，如果属性值是引用类型复制的将是引用值。
  -->
  <script>
    function _clone(target, origin) {
      for (let key in origin) target[key] = origin[key];
      return target;
    }
    var origin = {
      name: "origin",
      age: 10,
      house: {
        width: 100,
        height: 300,
      },
      maps: [1, 2, 3, 4],
    };
    origin.__proto__.name = "proto_test";
    console.log(_clone(origin));
  </script>

  <!-- 
    深拷贝实现递归拷贝对象，避免复制多层引用类型数据嵌套问题。
  -->
  <script>
    function _deepClone(target, origin) {
      var toString = Object.prototype.toString;
      for (var key in origin) {
        if (origin[key] && origin.hasOwnProperty(key)) {
          if (typeof origin[key] === "object") {
            if (toString.call(origin[key]).slice(8, -1) === "Array") {
              target[key] = _deepClone([], origin[key]);
            } else {
              target[key] = _deepClone({}, origin[key]);
            }
          } else {
            target[key] = origin[key];
          }
        }
      }
      return target;
    }
    var obj = _deepClone({}, origin);
    obj.name = "object";
    obj.house.height = 500;
    obj.maps.push(5);
    console.log(obj);
  </script>

  <!-- 
    深拷贝另一种方式
    使用序列化形式进行字符串与对象互转 JSON.stringify 和 JSON.parse。
  -->
  <script>
    var jsonObj = {
      name: "jsonObj",
      eat: function () {}, // => 无法复制
      undf: undefined, // => 无法复制
      regexp: /^\d+/, // => {}
      symbol: Symbol("little"), // 无法复制
      null: null,
      date: new Date(),
    };
    console.log(JSON.parse(JSON.stringify(jsonObj)));
  </script>
</html>
